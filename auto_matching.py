#! /usr/bin/python
try:
    from jinja2 import Environment, FileSystemLoader
except ImportError as msg:
    print ("ImportError: %s" % msg)
    exit(1)
import os
try:
    import numpy as np
except ImportError as msg:
    print ("ImportError: %s" % msg)
    exit(1)

import re

#
# # get options from command line
# def get_opt():
#     parser = argparse.ArgumentParser(description="BipartMatching Generator")
#     parser.add_argument('-p', "--position", action="store", help="weight position", type=int, default=0)
#     parser.add_argument('-s', "--size", action="store", help="matching size", type=int, default=8)
#     parser.add_argument('-w', "--minWeight", action="store", help="minimum weight on each edge", type=int, default=0)
#     parser.add_argument('-W', "--maxWeight", action="store", help="maximum weight on each edge", type=int, default=100)
#     parser.add_argument('-f', "--file", action="store", help="custom data for a matching", type=str, default="")
#     parser.add_argument('-c', "--consistency", action="store", help="consistent matching data from the same graph", type=str, default="")
#     parser.add_argument('-o', "--output", action="store", help="output file name (for example, test.tex)", type=str, default="bm.tex")
#
#
#     try:
#         args = parser.parse_args(sys.argv[1::])
#     except IOError as msg:
#         parser.error(str(msg))
#         exit(1)
#     return args


# generate random matching
def gen_random_matching(N, min_weight=1, max_weight=50, consistent_with=None):
    """Generate a random matching.

    Args:
        N : matching size (int)
        min_weight: minimum weight for each edge (int)
        max_weight: maximum weight for each edge (int)
        consistent_with: edges (with weights) from the same graph,
                         that the generated matching needs to be
                         consistent with (dict)
    """

    m = np.random.permutation(N).tolist()
    matching = []
    weights = np.random.randint(min_weight, high=max_weight, size=N)

    cons_matching = {}
    if not (consistent_with is None):
        cons_matching = consistent_with
 
    for i, o in enumerate(m):
        w = weights[i]
        e = (str(i + 1), str(o + 1))
        if e in cons_matching:
            w = cons_matching[e]
        matching.append({'i': i + 1, 'o': o + 1, 'w': w })
    return matching


def json_form(matching):
    """Reformat your matching.
    
    Args:
        matching: a tuple of matching with weight, i.e., (matching, weight)
                  where matching is described by a list as a permutation, 
                  weight is dict with input port as key.
    
    Note that, both input ports and output ports start from 0.
    
    """
    m = []
    for i, o in enumerate(matching[0]):
        m.append(dict(zip(['i', 'o', 'w'],
                          [i + 1, o + 1, matching[1][i]])))
    
    return m

def to_tuple(matching):
    """Reformat matching as a tuple
    
    inverse function of json_form
    """
    m = [0] * len(matching)
    weights = {}
    for e in matching:
        i = e['i'] - 1
        o = e['o'] - 1
        w = e['w']
        m[i] = o
        weights[i] = w
    return m, weights
        
    
# Capture our current directory
THIS_DIR = os.path.dirname(os.path.abspath(__file__))
DEFAULT_TEMPLATE = u'matching_template.tex'


def get_tex_doc(matching, **options):
    """Generate tex code for a matching"""

    template_dir = options.get("template_dir", THIS_DIR)
    template_filename = options.get("template", DEFAULT_TEMPLATE)
    j2_env = Environment(loader=FileSystemLoader(template_dir),
                         trim_blocks=True)
    args = {'N': len(matching), 'matching': matching}
    args['position'] = options.get('position', 0)
    return j2_env.get_template(template_filename).render(
        args
    )


def gen_tex_file(tex_doc, filename="example.tex", overwrite_handler=None):
    """Write the tex code into a file"""
    add_msg = "%% This file is generated by Jinja2"

    if os.path.exists(filename):
        if not (overwrite_handler is None):
            if not overwrite_handler(filename):
                return False

    with open(filename, 'w') as texf:
        texf.write("%s\n" % add_msg)
        texf.write(tex_doc)
    return True


def auto_extract_bwm(filename):
    """Automatically analyze TeX file, extract the weighted matching

    Note that, this function only supports extracting bipartite weighted
    matching (bwm) from the TeX file generated by auto_matching.py.
    """

    # regular expression pattern for extracting weight
    # Note that, currently we only support the cases
    # where the description of a node is on a single
    # line (similar for edge pattern)
    _WEIGHT = re.compile(r"\\node\[weight\]\s*\(W-(\d+)\)"
                         r"\s*at\s*\(.*\)\s*\{\$(\d+)\$\}", re.MULTILINE)
    _EDGE = re.compile(r"\\foreach\s*\\i/\\o\s*in\s*\{\s*(.+)\s*\}",
                       re.MULTILINE)

    matching = []
    weight = {}

    with open(filename, 'r') as fp:
        for line in fp:
            weight_g = re.match(_WEIGHT, line)
            if not (weight_g is None):
                ind, w = weight_g.groups()
                weight[int(ind) - 1] = int(w)
            else:
                edegs_g = re.match(_EDGE, line)
                if not (edegs_g is None):
                    edges = edegs_g.groups()[0]
                    edge = re.split(r"\s*,\s*", edges)
                    matching = [0] * len(edge)
                    for io in edge:
                        i, o = io.split('/')
                        try:
                            matching[int(i) - 1] = int(o) - 1
                        except IndexError as msg:
                            print("File analysis failed, cannot"
                                  "read matching because %s" % str(msg))

    return matching, weight

# if __name__ == '__main__':
#     args = get_opt()
#     # print str(args)
#     consistency = None
#     if len(args.consistency) > 0:
#         consistency = args.consistency
#
#
#     matching = gen_random_matching(args.size, min_weight=args.minWeight, max_weight=args.maxWeight, check_file=consistency)
#     # print matching
#     doc = get_tex_doc(matching, position=args.position)
#     gen_tex_file(doc, filename=args.output)

